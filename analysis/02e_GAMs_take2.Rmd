---
title: "02e_GAMs_take2"
author: "Julia Pop"
date: "2025-10-27"
output: html_document
---

```{r setup, include=FALSE}
# code to troublesheet file path issues. 
# By default, knitr uses the folder containing the .Rmd file as
# the working directory. This code allows us to set the folder
# with our .rProj in it as the root. 

# find_root looks upwards from the .Rmd until it finds a file or
# folder that matches the criteria "folder with a .Rproj file in
# it."

knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::is_rstudio_project))
```

#Libraries -- add these here
```{r, echo = FALSE}
source("scripts/libraries.R")
source("scripts/GAM_functions.R")
```


## Pull in data
```{r}
UFM_short_extrap <- read.csv("output/UFM_short_extrap.csv") %>%
  select(-X)
LFM_short_extrap <- read.csv("output/LFM_short_extrap.csv") %>%
  select(-X)
TRK_short <- read.csv("output/TRK_short.csv") %>%
  select(-X)
```

**Go back and explore the models later to see how correlation structures and weights affect model performance**

# TRK

## d15N
Model the full timeseries from year_plot_extrap instead of year_plot_extrap - IAO
```{r}

### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(TRK_short$year_plot_extrap)) # 10 observations... not so many
    sum(!is.na(TRK_short$year_plot_extrap)) # 41 observations. 

# try with and without corCAR1, then examine the residuals. 
mod_d15N_TRK <- gam(d15N ~ s(year_plot_extrap, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_d15N_TRK)

resid_values_d15N_TRK <- residuals(mod_d15N_TRK, type = "response")
acf(resid_values_d15N_TRK) # looks good!

## summary object for use in document
d15NSumm_TRK <- summary(mod_d15N_TRK)
d15NSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d15N_TRK)
par(mfrow = c(1, 1)) 




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Predict (get 200 points at which to evaluate)
d15NYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d15NYear_TRK <- cbind(d15NYear_TRK,
                      data.frame(predict(mod_d15N_TRK, d15NYear_TRK,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_TRK <- transform(d15NYear_TRK, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_TRK$lake_ID <- 'TRK'

## Plot fitted trends
ggplot(d15NYear_TRK, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_d15N <- 
ggplot(TRK_short) +
    #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_d15N #Saves the plot as an object -- need to do this this way for arranging plots with patchwork() later

ggsave("figures/TRK_d15N.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


## d13C
Use TRK_short to be able to plot all the data vs. time, but model only the interpolated dates. 
```{r}

# check later how weights, corCAR1 compare. 
    
mod_d13C_TRK <- gam(d13C ~ s(year_plot_extrap, k = 15), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_d13C_TRK) # using REML - good.

resid_values_d13C_TRK <- residuals(mod_d13C_TRK, type = "response")
acf(resid_values_d13C_TRK) # has neg lag

## summary object for use in document
d13CSumm_TRK <- summary(mod_d13C_TRK)
d13CSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d13C_TRK)
par(mfrow = c(1, 1)) 


### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d13CYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d13CYear_TRK <- cbind(d13CYear_TRK,
                      data.frame(predict(mod_d13C_TRK, d13CYear_TRK,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d13CYear_TRK <- transform(d13CYear_TRK, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d13CYear_TRK$lake_ID <- 'TRK'

## Plot fitted trends
ggplot(d13CYear_TRK, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = d13C), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d13C_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d13CYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_d13C <- ggplot(TRK_short) +
    #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, d13C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{13}, "C (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_d13C

ggsave("figures/TRK_d13C.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```



## percent C
```{r}

# breaks = ?
  hist(TRK_short$percent.C)
  hist(log(TRK_short$percent.C))
  
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perC_TRK <- gam(percent.C ~ s(year_plot_extrap, k = 10), 
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perC_TRK) # using ML because of the Gamma family designation

resid_values_perC_TRK <- residuals(mod_perC_TRK, type = "response")
acf(resid_values_perC_TRK) # acf looks good

## summary object for use in document
perCSumm_TRK <- summary(mod_perC_TRK)
perCSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perC_TRK)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.C): 
fam<-family(mod_perC_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perCYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
perCYear_TRK <- cbind(perCYear_TRK,
                      data.frame(predict(mod_perC_TRK, perCYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perCYear_TRK <- transform(perCYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perCYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(perCYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = percent.C), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perC_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perCYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_percC <- ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Carbon (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_percC

ggsave("figures/TRK_perC.png",
       dpi=600,
       height=5,
       width=8,
       units="in")


ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  # add points for C.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, C.mar * 1000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, C.mar * 1000),
            color = "red", linetype = "dashed") +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  # secondary y-axis
  scale_y_continuous(
    name = "Total Carbon (%)",
    sec.axis = sec_axis(~ . / 1000, name = "Carbon MAR")
  ) +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

```


## percent N
```{r}

  hist(TRK_short$percent.N)
  hist(log(TRK_short$percent.N))


# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perN_TRK <- gam(percent.N ~ s(year_plot_extrap, k = 10), 
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perN_TRK) # using ML because of the Gamma family designation

resid_values_perN_TRK <- residuals(mod_perN_TRK, type = "response")
acf(resid_values_perN_TRK) 
# negative response at lag 1

## summary object for use in document
perNSumm_TRK <- summary(mod_perN_TRK)
perNSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perN_TRK)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.N): 
fam<-family(mod_perN_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perNYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perNYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
perNYear_TRK <- cbind(perNYear_TRK,
                      data.frame(predict(mod_perN_TRK, perNYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perNYear_TRK <- transform(perNYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perNYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(perNYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = percent.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perN_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perNYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_percN <- ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Nitrogen (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_percN

ggsave("figures/TRK_perN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  # add points for N.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, N.mar * 1000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, N.mar * 1000),
            color = "red", linetype = "dashed") +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
   # secondary y-axis
  scale_y_continuous(
    name = "Total Nitrogen (%)",
    sec.axis = sec_axis(~ . / 1000, name = "Nitrogen MAR")
  ) +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")


```

## C:N -> wierd data distribution!

**Note** the wierd skew on this when compiling presentation. 

```{r}
# this column name is annoying so change it to match LFM
  # names(TRK_short)
  # TRK_short <- rename(TRK_short, C.N = `C:N`)

# check later how weights, corCAR1 compare. 
    
  hist(TRK_short$C.N)
  hist(log(TRK_short$C.N))
  # data is left skewed, log transform makes it worse? in this case it looks a little better?
    
# mod_CN_TRK <- gamm(C.N ~ s(year_plot_extrap, k = 10), 
#                      family = gaussian(link = "identity"), 
#                      data = TRK_short,
#                    #  correlation = corCAR1(form = ~ year_plot_extrap),
#                      method = "REML")

# IAO - version 2 with Gamma because data are left-skewed, all positive
mod_CN_TRK <- gam(C.N ~ s(year_plot_extrap, k = 20),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_CN_TRK)$dev.expl  # deviance explained

AIC(mod_CN_TRK)
summary(mod_CN_TRK)

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_CN_TRK)
par(mfrow = c(1, 1)) 

# p value too low if you change anything (add car 1 etc.)

    resid_values_CN_TRK <- residuals(mod_CN_TRK$lme, type = "response")
    acf(resid_values_CN_TRK) 
    # residuals significant, def structured, corCAR1 helps a little but sample size is too small to use it.
    
## summary object for use in document
CNSumm_TRK <- summary(mod_CN_TRK$gam)
CNSumm_TRK #Gives you the P values, degrees of freedom...




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
CNYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the response scale
CNYear_TRK <- cbind(CNYear_TRK,
                      data.frame(predict(mod_CN_TRK$gam, CNYear_TRK,
                                         type="response", se.fit = TRUE)))

# calculate 95% CIs, on the response scale 

CNYear_TRK <- transform(CNYear_TRK,
  upper = fit + 2 * se.fit,
  lower = fit - 2 * se.fit)

CNYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(CNYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = C.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_CN_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(CNYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, C.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("C.N ratio") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_CN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

##Pigments
###Pheo a
```{r}
# compare data distributions
  hist(TRK_short$pheo_a_nmol_gTC)
  hist(log(TRK_short$pheo_a_nmol_gTC)) # better!

    # check later how weights, corCAR1 compare. 
    
mod_pheoa_TRK <- gam(pheo_a_nmol_gTC ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_pheoa_TRK) # using ML because of the Gamma family designation

resid_values_pheoa_TRK <- residuals(mod_pheoa_TRK, type = "response")
acf(resid_values_pheoa_TRK) 

## summary object for use in document
pheoaSumm_TRK <- summary(mod_pheoa_TRK)
pheoaSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_pheoa_TRK)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_pheoa_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

plot(mod_pheoa_TRK)
### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
pheoaYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
pheoaYear_TRK <- cbind(pheoaYear_TRK,
                      data.frame(predict(mod_pheoa_TRK, pheoaYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
pheoaYear_TRK <- transform(pheoaYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

pheoaYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(pheoaYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = pheo_a_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_pheoa_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(pheoaYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_total_algae <- ggplot(TRK_short) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, pheo_a_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheophytin a ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_pheo_a.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Greens
```{r}
# compare data distributions
  hist(TRK_short$greens)
  hist(log(TRK_short$greens)) # log is better

    # check later how weights, corCAR1 compare. 
    
mod_greens_TRK <- gam(greens ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_greens_TRK) # using ML because of the Gamma family designation

resid_values_greens_TRK <- residuals(mod_greens_TRK, type = "response")
acf(resid_values_greens_TRK) # looks good!

## summary object for use in document
greensSumm_TRK <- summary(mod_greens_TRK)
greensSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_greens_TRK)
par(mfrow = c(1, 1)) 


### now transform response variable:
fam<-family(mod_greens_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
greensYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
greensYear_TRK <- cbind(greensYear_TRK,
                      data.frame(predict(mod_greens_TRK, greensYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
greensYear_TRK <- transform(greensYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

greensYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(greensYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = greens), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_greens_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(greensYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_greens <- ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, greens)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheo b & lutein ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_greens

ggsave("figures/TRK_greens.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Diatoxanthin
```{r}

# compare data distributions
  hist(TRK_short$diato_nmol_gTC)
  hist(log(TRK_short$diato_nmol_gTC)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_diato_TRK <- gam(diato_nmol_gTC ~ s(year_plot_extrap, k = 20),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_diato_TRK) # using ML because of the Gamma family designation

resid_values_diato_TRK <- residuals(mod_diato_TRK, type = "response")
acf(resid_values_diato_TRK) # same negative acf right at lag 1, not huge though

## summary object for use in document
diatoSumm_TRK <- summary(mod_diato_TRK)
diatoSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_diato_TRK)
par(mfrow = c(1, 1)) 

      # not great... k=index less than 1, though p-value is fine

### now transform response variable:
fam<-family(mod_diato_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
diatoYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
diatoYear_TRK <- cbind(diatoYear_TRK,
                      data.frame(predict(mod_diato_TRK, diatoYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
diatoYear_TRK <- transform(diatoYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

diatoYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(diatoYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = diato_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_diato_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(diatoYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_diatoms<-ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, diato_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("diatoxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_diatoms

ggsave("figures/TRK_diato.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Alloxanthin
```{r}

# compare data distributions
  hist(TRK_short$allo_nmol_gTC)
  hist(log(TRK_short$allo_nmol_gTC)) # log transformation not that helpful but use it out of principle? 

    # check later how weights, corCAR1 compare. 
    
# mod_allo_TRK <- gam(allo_nmol_gTC ~ s(year_plot_extrap, k = 20),
#                      family=Gamma(link="log"),  
#                      data = TRK_short,
#                      # REML only works for gaussian data
#                      method = "ML")

#Gaussian model fit looked better. There were really large error bars
  # with the Gamma distribution
mod_allo_TRK <- gam(allo_nmol_gTC ~ s(year_plot_extrap, k = 15), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_allo_TRK) # using ML because of the Gamma family designation

resid_values_allo_TRK <- residuals(mod_allo_TRK, type = "response")
acf(resid_values_allo_TRK) # looks good!

## summary object for use in document
alloSumm_TRK <- summary(mod_allo_TRK)
alloSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_allo_TRK)
par(mfrow = c(1, 1)) 

      # not great...? k=index = 1, though p-value is fine

### now transform response variable:
fam<-family(mod_allo_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
alloYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
alloYear_TRK <- cbind(alloYear_TRK,
                      data.frame(predict(mod_allo_TRK, alloYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
alloYear_TRK <- transform(alloYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

alloYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(alloYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = allo_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_allo_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(alloYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_allo <- ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("alloxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_allo 

ggsave("figures/TRK_allo.png",
       dpi=600,
       height=5,
       width=8,
       units="in")


ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
   # add points for allo flux (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, allo_flux * 1000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, allo_flux * 1000),
            color = "red", linetype = "dashed") +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  scale_y_continuous(
    name = "alloxanthin ("*nmol~g^-1~"total carbon"*")",
    sec.axis = sec_axis(~ . / 1000, name = "Alloxanthin flux")
  ) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
```
###Cyanos
```{r}

# compare data distributions
  hist(TRK_short$cyanos)
  hist(log(TRK_short$cyanos)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_cyanos_TRK <- gam(cyanos ~ s(year_plot_extrap, k = 20),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_cyanos_TRK) # using ML because of the Gamma family designation

resid_values_cyanos_TRK <- residuals(mod_cyanos_TRK, type = "response")
acf(resid_values_cyanos_TRK) # looks good

## summary object for use in document
cyanosSumm_TRK <- summary(mod_cyanos_TRK)
cyanosSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_cyanos_TRK)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_cyanos_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
cyanosYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
cyanosYear_TRK <- cbind(cyanosYear_TRK,
                      data.frame(predict(mod_cyanos_TRK, cyanosYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
cyanosYear_TRK <- transform(cyanosYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

cyanosYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(cyanosYear_TRK, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = cyanos), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_cyanos_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(cyanosYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))


# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

TRK_cyanos <- ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
TRK_cyanos

ggsave("figures/TRK_cyanos.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

ggplot(TRK_short) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  # add points for echine flux (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, echine_flux * 100),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, echine_flux * 100),
            color = "red", linetype = "dashed") +
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  # secondary y-axis
  scale_y_continuous(
    name = "echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")",
    sec.axis = sec_axis(~ . / 100, name = "Echinenone flux")
  ) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")
```

###Preservation index
```{r}

TRK_short_PI <- TRK_short %>% drop_na(year_plot_extrap, PI)

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(TRK_short_PI) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, PI)) +
#  geom_ribbon(data = pred,
#              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
#              alpha = 0.2) +
#  geom_line(data = pred,
#            aes(x = year_plot_extrap, y = fit),
#            linewidth = 1,
#            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
#  scale_color_manual(values = c("sig. inc." = "#CC9933",
#                                "sig. dec." = "#2f6cad"),
#                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  # Added for non gam version - connect points with a line
  geom_line(aes(x = year_plot_extrap, y = PI), 
            linewidth = 0.8, color = "black") +
  # Add dashed reference line at y = 1
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", linewidth = 0.7) +
  ylab(expression("Preservation Index")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_PI.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


# LFM
```{r}
# plot only 1860 onwards, and interpret changes across the whole core...
LFM_short_extrap <- LFM_short_extrap %>%
  filter(year_plot_extrap>1860)
```

## d15N

```{r}
### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(LFM_short_extrap$year_plot_extrap)) # 43 observations. 

# Weights didn't help at all above. Model here without... 
    
# try with and without corCAR1, then examine the residuals. 
mod_d15N_LFM <- gam(d15N ~ s(year_plot_extrap, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     method = "REML")

mod_d15N_LFM_CAR1_ex <- gam(d15N ~ s(year_plot_extrap, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     correlation = corCAR1(form = ~ year_plot_extrap),
                     method = "REML")

summary(mod_d15N_LFM_CAR1_ex) # no longer overriding reml! that's good.

resid_values_ex <- residuals(mod_d15N_LFM, type = "response")       # no CAR(1)
resid_values_CAR1_ex <- residuals(mod_d15N_LFM_CAR1_ex, type = "response")   # with CAR(1)
all.equal(resid_values_ex, resid_values_CAR1_ex)  # Check if they are identical
# same! so CAR1 isn't helping -> drop

acf(resid_values_ex)
acf(resid_values_CAR1_ex)

# examine again using AIC:
AIC(mod_d15N_LFM)   # without CAR(1): -0.57
# AIC(mod_d15N_LFM_CAR1) # with CAR(1) from before: -4.84 (don't compare, was with ML)
AIC(mod_d15N_LFM_CAR1_ex) # with CAR(1) now: 1.42
# lower AIC = better? better with CAR(1) still. 
# AIC=2k2ln(L), where k = # parameters, L = likelihood.

    ### DECISION: move forward with mod_d15N_LFM (no weights, no CAR1) ###

## summary object for use in document
d15NSumm_LFM_ex <- summary(mod_d15N_LFM)
d15NSumm_LFM_ex #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model


par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d15N_LFM)
par(mfrow = c(1, 1)) 





### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d15NYear_LFM_ex <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d15NYear_LFM_ex <- cbind(d15NYear_LFM_ex,
                      data.frame(predict(mod_d15N_LFM, d15NYear_LFM_ex,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_LFM_ex <- transform(d15NYear_LFM_ex, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_LFM_ex$lake_ID <- 'LFM'

## Plot fitted trends
ggplot(d15NYear_LFM_ex, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_LFM_ex,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_d15N <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_d15N

ggsave("figures/LFM_d15N.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

## d13C
Use LFM_short_extrap to be able to plot all the data vs. time, but model only the interpolated dates. 
```{r}
# check later how weights, corCAR1 compare. 
sum(!is.na(LFM_short_extrap$year_plot_extrap)) # 43 observations. 

# use year_CE_plot instead?
sum(!is.na(LFM_short_extrap$year_CE_plot)) # 18 observations. 


# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_d13C_LFM <- gam(d13C ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     method = "REML")

summary(mod_d13C_LFM) # using REML - good.

resid_values_d13C_LFM <- residuals(mod_d13C_LFM, type = "response")
acf(resid_values_d13C_LFM) # no lag, looks good without...

## summary object for use in document
d13CSumm_LFM <- summary(mod_d13C_LFM)
d13CSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d13C_LFM)
par(mfrow = c(1, 1)) 


### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d13CYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

d13CYear_LFM <- cbind(d13CYear_LFM,
                      data.frame(predict(mod_d13C_LFM, d13CYear_LFM,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d13CYear_LFM <- transform(d13CYear_LFM, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d13CYear_LFM$lake_ID <- 'LFM'

## Plot fitted trends
ggplot(d13CYear_LFM, aes(x = year_CE_plot, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE_plot),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = LFM_short_extrap, mapping = aes(x = year_CE_plot, y = d13C), inherit.aes = FALSE) +
  geom_line() 

# year_CE_plot = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d13C_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d13CYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_d13C <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_CE_plot, d13C)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1860,2025,by=25))+
  ylab(expression(paste(delta^{13}, "C (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_d13C

ggsave("figures/LFM_d13C.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

## percent C
```{r}

  hist(LFM_short_extrap$percent.C)
  hist(log(LFM_short_extrap$percent.C))
  
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perC_LFM <- gam(percent.C ~ s(year_plot_extrap, k = 10), 
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perC_LFM) # using ML because of the Gamma family designation

resid_values_perC_LFM <- residuals(mod_perC_LFM, type = "response")
acf(resid_values_perC_LFM) 

## summary object for use in document
perCSumm_LFM <- summary(mod_perC_LFM)
perCSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perC_LFM)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.C): 
fam<-family(mod_perC_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perCYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
perCYear_LFM <- cbind(perCYear_LFM,
                      data.frame(predict(mod_perC_LFM, perCYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perCYear_LFM <- transform(perCYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perCYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(perCYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.C), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perC_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perCYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_percC <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Carbon (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_percC

ggsave("figures/LFM_perC.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  # add points for C.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, C.mar * 1000 + 4),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, C.mar * 1000 + 4),
            color = "red", linetype = "dashed") +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  scale_y_continuous(
    name = "Total Carbon (%)",
    sec.axis = sec_axis(~ . / 1000 - 1/250, name = "Carbon MAR")
  ) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

```


## percent N
```{r}

  hist(LFM_short_extrap$percent.N)
  hist(log(LFM_short_extrap$percent.N))

# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perN_LFM <- gam(percent.N ~ s(year_plot_extrap, k = 10), 
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perN_LFM) # using ML because of the Gamma family designation

resid_values_perN_LFM <- residuals(mod_perN_LFM, type = "response")
acf(resid_values_perN_LFM) 
# negative response at lag 1

## summary object for use in document
perNSumm_LFM <- summary(mod_perN_LFM)
perNSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perN_LFM)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.N): 
fam<-family(mod_perN_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perNYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perNYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
perNYear_LFM <- cbind(perNYear_LFM,
                      data.frame(predict(mod_perN_LFM, perNYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perNYear_LFM <- transform(perNYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perNYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(perNYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perN_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perNYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_percN <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Nitrogen (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_percN

ggsave("figures/LFM_perN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
 # add points for N.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, N.mar * 2000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, N.mar * 2000),
            color = "red", linetype = "dashed") +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  scale_y_continuous(
    name = "Total Nitrogen (%)",
    sec.axis = sec_axis(~ . / 2000, name = "Nitrogen MAR")) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

```

## C:N -> wierd data distribution!

**Note** the wierd skew on this when compiling presentation. 

```{r}
# check later how weights, corCAR1 compare. 
    
  hist(LFM_short_extrap$C.N)
  hist(log(LFM_short_extrap$C.N))
  # data is left skewed, log transform makes it worse
    
mod_CN_LFM <- gam(C.N ~ s(year_plot_extrap, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                   #  correlation = corCAR1(form = ~ year_plot_extrap),
                     method = "REML")

AIC(mod_CN_LFM) 
summary(mod_CN_LFM)

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_CN_LFM)
par(mfrow = c(1, 1)) 

# p value too low if you change anything (add car 1 etc.)

    resid_values_CN_LFM <- residuals(mod_CN_LFM, type = "response")
    acf(resid_values_CN_LFM) 
    # residuals significant, def structured, corCAR1 helps a little bit but sample size is too small to use it.
    
## summary object for use in document
CNSumm_LFM <- summary(mod_CN_LFM)
CNSumm_LFM #Gives you the P values, degrees of freedom...




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
CNYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the response scale
CNYear_LFM <- cbind(CNYear_LFM,
                      data.frame(predict(mod_CN_LFM, CNYear_LFM,
                                         type="response", se.fit = TRUE)))

# calculate 95% CIs, on the response scale 

CNYear_LFM <- transform(CNYear_LFM,
  upper = fit + 2 * se.fit,
  lower = fit - 2 * se.fit)

CNYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(CNYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = C.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

fd_inc = confint(fderiv(mod_CN_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend

plot(mod_CN_LFM, rug=TRUE, shade=TRUE)



# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(CNYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_CN <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, C.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("C:N ratio") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_CN

ggsave("figures/LFM_CN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

##Pigments
###Pheo a
```{r}
# compare data distributions
  hist(LFM_short_extrap$pheo_a_nmol_gTC)
  hist(log(LFM_short_extrap$pheo_a_nmol_gTC))
    
mod_pheoa_LFM <- gam(pheo_a_nmol_gTC ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_pheoa_LFM) # using ML because of the Gamma family designation

resid_values_pheoa_LFM <- residuals(mod_pheoa_LFM, type = "response")
acf(resid_values_pheoa_LFM) # looks good!

## summary object for use in document
pheoaSumm_LFM <- summary(mod_pheoa_LFM)
pheoaSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_pheoa_LFM)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_pheoa_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
pheoaYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
pheoaYear_LFM <- cbind(pheoaYear_LFM,
                      data.frame(predict(mod_pheoa_LFM, pheoaYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
pheoaYear_LFM <- transform(pheoaYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

pheoaYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(pheoaYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = pheo_a_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_pheoa_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(pheoaYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_total_algae <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, pheo_a_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheophytin a ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_total_algae

ggsave("figures/LFM_pheo_a.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Greens
```{r}

# compare data distributions
  hist(LFM_short_extrap$greens)
  hist(log(LFM_short_extrap$greens))

# check later how weights, corCAR1 compare. 
    
mod_greens_LFM <- gam(greens ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_greens_LFM) # using ML because of the Gamma family designation

resid_values_greens_LFM <- residuals(mod_greens_LFM, type = "response")
acf(resid_values_greens_LFM) # looks good!

## summary object for use in document
greensSumm_LFM <- summary(mod_greens_LFM)
greensSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_greens_LFM)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_greens_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
greensYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
greensYear_LFM <- cbind(greensYear_LFM,
                      data.frame(predict(mod_greens_LFM, greensYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
greensYear_LFM <- transform(greensYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

greensYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(greensYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = greens), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_greens_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(greensYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_greens <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, greens)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheo b & lutein ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_greens

ggsave("figures/LFM_greens.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Diatoxanthin
```{r}

# compare data distributions
  hist(LFM_short_extrap$diato_nmol_gTC)
  hist(log(LFM_short_extrap$diato_nmol_gTC)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_diato_LFM <- gam(diato_nmol_gTC ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_diato_LFM) # using ML because of the Gamma family designation

resid_values_diato_LFM <- residuals(mod_diato_LFM, type = "response")
acf(resid_values_diato_LFM) # looks good

## summary object for use in document
diatoSumm_LFM <- summary(mod_diato_LFM)
diatoSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_diato_LFM)
par(mfrow = c(1, 1)) 

      # not great... k=index less than 1, though p-value is fine

### now transform response variable:
fam<-family(mod_diato_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
diatoYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
diatoYear_LFM <- cbind(diatoYear_LFM,
                      data.frame(predict(mod_diato_LFM, diatoYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
diatoYear_LFM <- transform(diatoYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

diatoYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(diatoYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = diato_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_diato_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(diatoYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_diatoms <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, diato_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("diatoxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_diatoms

ggsave("figures/LFM_diato.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Alloxanthin
```{r}

# compare data distributions
  hist(LFM_short_extrap$allo_nmol_gTC)
  hist(log(LFM_short_extrap$allo_nmol_gTC)) # log transformation not that helpful but use it out of principle? 

    # check later how weights, corCAR1 compare. 
    
mod_allo_LFM <- gam(allo_nmol_gTC ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_allo_LFM) # using ML because of the Gamma family designation

resid_values_allo_LFM <- residuals(mod_allo_LFM, type = "response")
acf(resid_values_allo_LFM) # looks good!

## summary object for use in document
alloSumm_LFM <- summary(mod_allo_LFM)
alloSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_allo_LFM)
par(mfrow = c(1, 1)) 

      # not great...? k=index = 1, though p-value is fine

### now transform response variable:
fam<-family(mod_allo_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
alloYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
alloYear_LFM <- cbind(alloYear_LFM,
                      data.frame(predict(mod_allo_LFM, alloYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
alloYear_LFM <- transform(alloYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

alloYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(alloYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = allo_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_allo_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(alloYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("alloxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_allo.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Cyanos
```{r}
# compare data distributions
  hist(LFM_short_extrap$cyanos)
  hist(log(LFM_short_extrap$cyanos)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_cyanos_LFM <- gam(cyanos ~ s(year_plot_extrap, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_cyanos_LFM) # using ML because of the Gamma family designation

resid_values_cyanos_LFM <- residuals(mod_cyanos_LFM, type = "response")
acf(resid_values_cyanos_LFM) # looks good

## summary object for use in document
cyanosSumm_LFM <- summary(mod_cyanos_LFM)
cyanosSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_cyanos_LFM)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_cyanos_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
cyanosYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
cyanosYear_LFM <- cbind(cyanosYear_LFM,
                      data.frame(predict(mod_cyanos_LFM, cyanosYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
cyanosYear_LFM <- transform(cyanosYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

cyanosYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(cyanosYear_LFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = cyanos), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_cyanos_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(cyanosYear_LFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1925, xmax = 2025, ymin = -Inf, ymax = Inf)

LFM_cyanos <- ggplot(LFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")
LFM_cyanos

ggsave("figures/LFM_cyanos.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Preservation index
```{r}

LFM_short_extrap_PI <- LFM_short_extrap %>% drop_na(year_plot_extrap, PI)

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(LFM_short_extrap_PI) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, PI)) +
#  geom_ribbon(data = pred,
#              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
#              alpha = 0.2) +
#  geom_line(data = pred,
#            aes(x = year_plot_extrap, y = fit),
#            linewidth = 1,
#            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
#  scale_color_manual(values = c("sig. inc." = "#CC9933",
#                                "sig. dec." = "#2f6cad"),
#                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  # Added for non gam version - connect points with a line
  geom_line(aes(x = year_plot_extrap, y = PI), 
            linewidth = 0.8, color = "black") +
  # Add dashed reference line at y = 1
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", linewidth = 0.7) +
  ylab(expression("Preservation Index")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_PI.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

# UFM
```{r}
# plot only 1860 onwards, and interpret changes across the whole core...
UFM_short_extrap <- UFM_short_extrap %>%
  filter(year_plot_extrap>1860)
# View(UFM_short_extrap)
```


## d15N
```{r}

### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(UFM_short_extrap$year_plot_extrap)) # 43 observations

# try with and without corCAR1, then examine the residuals. 
mod_d15N_UFM <- gam(d15N ~ s(year_plot_extrap, k = 5), 
                     family = gaussian(link = "identity"), 
                     data = UFM_short_extrap,
                     method = "REML")

summary(mod_d15N_UFM)

resid_values_d15N_UFM <- residuals(mod_d15N_UFM, type = "response")
acf(resid_values_d15N_UFM) # looks good!

## summary object for use in document
d15NSumm_UFM <- summary(mod_d15N_UFM)
d15NSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_d15N_UFM)




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Predict (get 200 points at which to evaluate)
d15NYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d15NYear_UFM <- cbind(d15NYear_UFM,
                      data.frame(predict(mod_d15N_UFM, d15NYear_UFM,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_UFM <- transform(d15NYear_UFM, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_UFM$lake_ID <- 'UFM'

## Plot fitted trends
ggplot(d15NYear_UFM, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_d15N <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_d15N

ggsave("figures/UFM_d15N.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

## d13C
Use UFM_short_extrap to be able to plot all the data vs. time, but model only the interpolated dates. 
```{r}

# check later how weights, corCAR1 compare. 
    
mod_d13C_UFM <- gam(d13C ~ s(year_plot_extrap, k = 5), 
                     family = gaussian(link = "identity"), 
                     data = UFM_short_extrap,
                     method = "REML")

summary(mod_d13C_UFM) # using REML - good.

resid_values_d13C_UFM <- residuals(mod_d13C_UFM, type = "response")
acf(resid_values_d13C_UFM) # has neg lag

## summary object for use in document
d13CSumm_UFM <- summary(mod_d13C_UFM)
d13CSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_d13C_UFM)


### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d13CYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d13CYear_UFM <- cbind(d13CYear_UFM,
                      data.frame(predict(mod_d13C_UFM, d13CYear_UFM,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d13CYear_UFM <- transform(d13CYear_UFM, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d13CYear_UFM$lake_ID <- 'UFM'

## Plot fitted trends
ggplot(d13CYear_UFM, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = d13C), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d13C_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d13CYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_d13C <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, d13C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab(expression(paste(delta^{13}, "C (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_d13C

ggsave("figures/UFM_d13C.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```



## percent C
```{r}

# breaks = ?
  hist(UFM_short_extrap$percent.C)
  hist(log(UFM_short_extrap$percent.C))
  
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perC_UFM <- gam(percent.C ~ s(year_plot_extrap, k = 5), 
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perC_UFM) # using ML because of the Gamma family designation

resid_values_perC_UFM <- residuals(mod_perC_UFM, type = "response")
acf(resid_values_perC_UFM) # acf looks good

## summary object for use in document
perCSumm_UFM <- summary(mod_perC_UFM)
perCSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_perC_UFM)

### now transform response variable (in this case percent.C): 
fam<-family(mod_perC_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perCYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
perCYear_UFM <- cbind(perCYear_UFM,
                      data.frame(predict(mod_perC_UFM, perCYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perCYear_UFM <- transform(perCYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perCYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"
     
## Plot fitted trends
ggplot(perCYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.C), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perC_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perCYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_percC <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Carbon (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_percC

ggsave("figures/UFM_perC.png",
       dpi=600,
       height=5,
       width=8,
       units="in")


ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
 # add points for C.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, C.mar * 5000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, C.mar * 5000),
            color = "red", linetype = "dashed") +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  scale_y_continuous(
    name = "Total Carbon (%)",
    sec.axis = sec_axis(~ . / 5000, name = "Carbon MAR")) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
  
```


## percent N
```{r}

  hist(UFM_short_extrap$percent.N)
  hist(log(UFM_short_extrap$percent.N))


# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perN_UFM <- gam(percent.N ~ s(year_plot_extrap, k = 5), 
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perN_UFM) # using ML because of the Gamma family designation

resid_values_perN_UFM <- residuals(mod_perN_UFM, type = "response")
acf(resid_values_perN_UFM) 
# negative response at lag 1

## summary object for use in document
perNSumm_UFM <- summary(mod_perN_UFM)
perNSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_perN_UFM)

### now transform response variable (in this case percent.N): 
fam<-family(mod_perN_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
perNYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perNYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
perNYear_UFM <- cbind(perNYear_UFM,
                      data.frame(predict(mod_perN_UFM, perNYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perNYear_UFM <- transform(perNYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perNYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"
     
## Plot fitted trends
ggplot(perNYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perN_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perNYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_percN <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab("Total Nitrogen (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_percN

ggsave("figures/UFM_perN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
# add points for N.Mar (scaled to fit this axis)
  geom_point(aes(year_plot_extrap, N.mar * 10000),
             color = "red", shape = 15, size = 2) +
  geom_line(aes(year_plot_extrap, N.mar * 10000),
            color = "red", linetype = "dashed") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  scale_y_continuous(
    name = "Total Nitrogen (%)",
    sec.axis = sec_axis(~ . / 10000, name = "Nitrogen MAR")
  ) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")

```

## C:N -> wierd data distribution!

**Note** the wierd skew on this when compiling presentation. 

```{r}
# If the code isn't running migth have to rename C:N in UFM_short_extrap
# UFM_short_extrap <- rename(UFM_short_extrap, C.N = `C:N`)
names(UFM_short_extrap)

# check later how weights, corCAR1 compare. 
    
  hist(UFM_short_extrap$C.N)
  hist(log(UFM_short_extrap$C.N))
  # data is left skewed, log transform makes it worse? in this case it looks a little better?
    
mod_CN_UFM <- gam(C.N ~ s(year_plot_extrap, k = 5), 
                     family = gaussian(link = "identity"), 
                     data = UFM_short_extrap,
                   #  correlation = corCAR1(form = ~ year_plot_extrap),
                     method = "REML")

AIC(mod_CN_UFM) 
summary(mod_CN_UFM)

### Check diagnostics. You might need to adjust model
gam.check(mod_CN_UFM)

# p value too low if you change anything (add car 1 etc.)

    resid_values_CN_UFM <- residuals(mod_CN_UFM, type = "response")
    acf(resid_values_CN_UFM) 
    # residuals significant, def structured, corCAR1 helps a little but sample size is too small to use it.
    
## summary object for use in document
CNSumm_UFM <- summary(mod_CN_UFM)
CNSumm_UFM #Gives you the P values, degrees of freedom...




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
CNYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the response scale
CNYear_UFM <- cbind(CNYear_UFM,
                      data.frame(predict(mod_CN_UFM, CNYear_UFM,
                                         type="response", se.fit = TRUE)))

# calculate 95% CIs, on the response scale 

CNYear_UFM <- transform(CNYear_UFM,
  upper = fit + 2 * se.fit,
  lower = fit - 2 * se.fit)

CNYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"
     
## Plot fitted trends
ggplot(CNYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = C.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_CN_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(CNYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_CN <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, C.N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("C.N ratio") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_CN

ggsave("figures/UFM_CN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

##Pigments
###Pheo a
```{r}
# compare data distributions
  hist(UFM_short_extrap$pheo_a_nmol_gTC)
  hist(log(UFM_short_extrap$pheo_a_nmol_gTC)) # better!

    # check later how weights, corCAR1 compare. 
    
mod_pheoa_UFM <- gam(pheo_a_nmol_gTC ~ s(year_plot_extrap, k = 5),
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_pheoa_UFM) # using ML because of the Gamma family designation

resid_values_pheoa_UFM <- residuals(mod_pheoa_UFM, type = "response")
acf(resid_values_pheoa_UFM) # looks good!

## summary object for use in document
pheoaSumm_UFM <- summary(mod_pheoa_UFM)
pheoaSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_pheoa_UFM)

### now transform response variable:
fam<-family(mod_pheoa_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
pheoaYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
pheoaYear_UFM <- cbind(pheoaYear_UFM,
                      data.frame(predict(mod_pheoa_UFM, pheoaYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
pheoaYear_UFM <- transform(pheoaYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

pheoaYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"

## Plot fitted trends
ggplot(pheoaYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = pheo_a_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_pheoa_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(pheoaYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_total_algae <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, pheo_a_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheophytin a ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_total_algae 

ggsave("figures/UFM_pheo_a.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Greens
```{r}
# compare data distributions
  hist(UFM_short_extrap$greens)
  hist(log(UFM_short_extrap$greens)) # log is better

    # check later how weights, corCAR1 compare. 
    
mod_greens_UFM <- gam(greens ~ s(year_plot_extrap, k = 5),
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_greens_UFM) # using ML because of the Gamma family designation

resid_values_greens_UFM <- residuals(mod_greens_UFM, type = "response")
acf(resid_values_greens_UFM) # looks good!

## summary object for use in document
greensSumm_UFM <- summary(mod_greens_UFM)
greensSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_pheoa_UFM)

### now transform response variable:
fam<-family(mod_greens_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
greensYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
greensYear_UFM <- cbind(greensYear_UFM,
                      data.frame(predict(mod_greens_UFM, greensYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
greensYear_UFM <- transform(greensYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

greensYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"

## Plot fitted trends
ggplot(greensYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = greens), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_greens_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(greensYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_greens <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, greens)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheo b & lutein ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_greens

ggsave("figures/UFM_greens.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Diatoxanthin
```{r}

# compare data distributions
  hist(UFM_short_extrap$diato_nmol_gTC)
  hist(log(UFM_short_extrap$diato_nmol_gTC)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_diato_UFM <- gam(diato_nmol_gTC ~ s(year_plot_extrap, k = 5),
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_diato_UFM) # using ML because of the Gamma family designation

resid_values_diato_UFM <- residuals(mod_diato_UFM, type = "response")
acf(resid_values_diato_UFM) # same negative acf right at lag 1, not huge though

## summary object for use in document
diatoSumm_UFM <- summary(mod_diato_UFM)
diatoSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_diato_UFM)

      # not great... k=index less than 1, though p-value is fine

### now transform response variable:
fam<-family(mod_diato_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
diatoYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
diatoYear_UFM <- cbind(diatoYear_UFM,
                      data.frame(predict(mod_diato_UFM, diatoYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
diatoYear_UFM <- transform(diatoYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

diatoYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"

## Plot fitted trends
ggplot(diatoYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = diato_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_diato_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(diatoYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_diatoms <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, diato_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab(expression("diatoxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_diatoms

ggsave("figures/UFM_diato.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Alloxanthin
```{r}

# compare data distributions
  hist(UFM_short_extrap$allo_nmol_gTC)
  hist(log(UFM_short_extrap$allo_nmol_gTC)) # log transformation not that helpful but use it out of principle? 

    # check later how weights, corCAR1 compare. 
    
mod_allo_UFM <- gam(allo_nmol_gTC ~ s(year_plot_extrap, k = 5),
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_allo_UFM) # using ML because of the Gamma family designation

resid_values_allo_UFM <- residuals(mod_allo_UFM, type = "response")
acf(resid_values_allo_UFM) # looks good!

## summary object for use in document
alloSumm_UFM <- summary(mod_allo_UFM)
alloSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_allo_UFM)

      # not great...? k=index = 1, though p-value is fine

### now transform response variable:
fam<-family(mod_allo_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
alloYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
alloYear_UFM <- cbind(alloYear_UFM,
                      data.frame(predict(mod_allo_UFM, alloYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
alloYear_UFM <- transform(alloYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

alloYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"

## Plot fitted trends
ggplot(alloYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = allo_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_allo_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(alloYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_allo <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("alloxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_allo

ggsave("figures/UFM_allo.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Cyanos
```{r}

# compare data distributions
  hist(UFM_short_extrap$cyanos)
  hist(log(UFM_short_extrap$cyanos)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_cyanos_UFM <- gam(cyanos ~ s(year_plot_extrap, k = 5),
                     family=Gamma(link="log"),  
                     data = UFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_cyanos_UFM) # using ML because of the Gamma family designation

resid_values_cyanos_UFM <- residuals(mod_cyanos_UFM, type = "response")
acf(resid_values_cyanos_UFM) # looks good

## summary object for use in document
cyanosSumm_UFM <- summary(mod_cyanos_UFM)
cyanosSumm_UFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
gam.check(mod_cyanos_UFM)

### now transform response variable:
fam<-family(mod_cyanos_UFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_plot_extrap values from min to max.
cyanosYear_UFM <- with(UFM_short_extrap, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), 
                                                   max(year_plot_extrap, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_UFM on the link scale
# if you do type = "response" se might still be on the link scale
cyanosYear_UFM <- cbind(cyanosYear_UFM,
                      data.frame(predict(mod_cyanos_UFM, cyanosYear_UFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
cyanosYear_UFM <- transform(cyanosYear_UFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

cyanosYear_UFM$lake_ID <- 'UFM' # add a column called lake_ID filled with values "UFM"

## Plot fitted trends
ggplot(cyanosYear_UFM, aes(x = year_plot_extrap, y = fit)) + # year_plot_extrap is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_plot_extrap),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = UFM_short_extrap, mapping = aes(x = year_plot_extrap, y = cyanos), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_plot_extrap where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_cyanos_UFM))
fd_inc

#Add years for plotting
years <- with(UFM_short_extrap,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(cyanosYear_UFM,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1949, xmax = 2025, ymin = -Inf, ymax = Inf)

UFM_cyanos <- ggplot(UFM_short_extrap) +
  #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")
UFM_cyanos

ggsave("figures/UFM_cyanos.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


###Preservation index
```{r}

UFM_short_extrap_PI <- UFM_short_extrap %>% drop_na(year_plot_extrap, PI)

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(UFM_short_extrap_PI) +
   #Add a box to show the reader the time period for interpretation
    geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE) + 
  geom_point(aes(year_plot_extrap, PI)) +
#  geom_ribbon(data = pred,
#              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
#              alpha = 0.2) +
#  geom_line(data = pred,
#            aes(x = year_plot_extrap, y = fit),
#            linewidth = 1,
#            color = "black") +
#  geom_line(data = pred2,
#            aes(x = year_plot_extrap, y = fit,
#                color = change_type,
#                group = seg_id),
#            linewidth = 1) +
#  scale_color_manual(values = c("sig. inc." = "#CC9933",
#                                "sig. dec." = "#2f6cad"),
#                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  # Added for non gam version - connect points with a line
  geom_line(aes(x = year_plot_extrap, y = PI), 
            linewidth = 0.8, color = "black") +
  # Add dashed reference line at y = 1
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", linewidth = 0.7) +
  ylab(expression("Preservation Index")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Upper Fourmile Lake")

ggsave("figures/UFM_PI.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

# Compile figures
## Figure 2? 3? SIA

```{r}

```

