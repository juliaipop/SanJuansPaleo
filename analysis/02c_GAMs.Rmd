---
title: "02c_GAMs"
author: "Julia Pop"
date: "2025-09-22"
output: html_document
---

```{r setup, include=FALSE}
# code to troublesheet file path issues. 
# By default, knitr uses the folder containing the .Rmd file as
# the working directory. This code allows us to set the folder
# with our .rProj in it as the root. 

# find_root looks upwards from the .Rmd until it finds a file or
# folder that matches the criteria "folder with a .Rproj file in
# it."

knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::is_rstudio_project))
```

#Libraries -- add these here
```{r, echo = FALSE}
source("scripts/libraries.R")
source("scripts/GAM_functions.R")
```

**NOTE! use the short files for the gams unless interested in comparing pigment units (g TC vs g dry mass)**

## Pull in data
```{r}
all_lakes <- read.csv("output/all_lakes.csv") %>%
  select(-X)

UFM_short_extrap <- read.csv("output/UFM_short_extrap.csv") %>%
  select(-X)
LFM_short <- read.csv("output/LFM_short.csv") %>%
  select(-X)
TRK_short <- read.csv("output/TRK_short.csv") %>%
  select(-X)

LFM_short_extrap <- read.csv("output/LFM_short_extrap.csv") %>%
  select(-X)
```

### Adding a weight term
Added the weight term already in 00_data_input_and_manipulation.Rmd. Instead of calculating weights with interval = lag(), weight corresponds to the duration captured by each slice, as in Simpson 2018. Addresses HETERO - SKA - DA - STI - CITY.

**Questions:** 
- Gamma distributed vs. gaussian distributed data... 

### Exploring interpolated d15N LFM 
```{r}
### FAMILY:
# For our purposes, family = gaussian (normal) for isotopes 
# (they can have negative and positive values), and
# family = gamma for concentrations and rates
# in that case the mean of the response variable is restricted to [0,inf)... 

### K (sets the maximum # of bases for our spline): 

# Our dataset is very small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(LFM_short$year_CE_plot)) # 18 observations. 
    
# try with and without corCAR1, and without weights then examine the residuals. 

# without weights
mod_d15N_LFM_nw <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     # does family correspond to the data or their residuals? 
                     # check with bella
                     data = LFM_short,
                     method = "REML")

# with weights, without car1
mod_d15N_LFM <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short,
                     weights = weight, 
                     method = "REML")

# with weights, with car1
mod_d15N_LFM_CAR1 <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short,
                     weights = weight, 
                     correlation = corCAR1(form = ~ year_CE_plot),
                     method = "REML")

resid_values_nw <- residuals(mod_d15N_LFM_nw$lme, type = "normalized") 
# no CAR(1), no weights
resid_values <- residuals(mod_d15N_LFM$lme, type = "normalized")  
# no CAR(1), with weights
resid_values_CAR1 <- residuals(mod_d15N_LFM_CAR1$lme, type = "normalized")   
# with CAR(1), with weights
all.equal(resid_values, resid_values_CAR1)  # Check if w and without car 1 are identical
# residuals are basically equal, so CAR(1) isn't doing much...

# check residuals
acf(resid_values_nw)
acf(resid_values)
acf(resid_values_CAR1)
# negative autocorrelation at lag 1, but CAR1 doesn't do anything about it...

# examine again using AIC:
AIC(mod_d15N_LFM_nw$lme) # without CAR(1) & without weights: -0.5703
# R is running the two models below this with ML instead of REML because of the weights. 
# to compare models, plot all with ML. then this AIC = -7.13, which is the best. so using no weight is ideal...
AIC(mod_d15N_LFM$lme)   # without CAR(1): -6.85481 
AIC(mod_d15N_LFM_CAR1$lme) # with CAR(1): -4.845512

summary(mod_d15N_LFM$gam)
summary(mod_d15N_LFM$lme)
summary(mod_d15N_LFM_nw$lme) # this one does use REML

gam.check(mod_d15N_LFM_nw$gam)
# best was without CAR1 and with the weights
# R is being annoying anyways and using ML instead of REML because of the weights... see if this matters in the future?
```


# LFM

## d15N

```{r}
### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(LFM_short_extrap$year_plot_extrap)) # 43 observations. 

# Weights didn't help at all above. Model here without... 
    
# try with and without corCAR1, then examine the residuals. 
mod_d15N_LFM_ex <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     method = "REML")

mod_d15N_LFM_CAR1_ex <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     correlation = corCAR1(form = ~ year_CE_plot),
                     method = "REML")

summary(mod_d15N_LFM_CAR1_ex$lme) # no longer overriding reml! that's good.

resid_values_ex <- residuals(mod_d15N_LFM_ex$lme, type = "normalized")       # no CAR(1)
resid_values_CAR1_ex <- residuals(mod_d15N_LFM_CAR1_ex$lme, type = "normalized")   # with CAR(1)
all.equal(resid_values_ex, resid_values_CAR1_ex)  # Check if they are identical
# same! so CAR1 isn't helping -> drop

acf(resid_values_ex)
acf(resid_values_CAR1_ex)

# examine again using AIC:
AIC(mod_d15N_LFM_ex$lme)   # without CAR(1): -0.57
# AIC(mod_d15N_LFM_CAR1$lme) # with CAR(1) from before: -4.84 (don't compare, was with ML)
AIC(mod_d15N_LFM_CAR1_ex$lme) # with CAR(1) now: 1.42
# lower AIC = better? better with CAR(1) still. 
# AIC=2kâˆ’2ln(L), where k = # parameters, L = likelihood.

    ### DECISION: move forward with mod_d15N_LFM_ex (no weights, no CAR1) ###

## summary object for use in document
d15NSumm_LFM_ex <- summary(mod_d15N_LFM_ex$gam)
d15NSumm_LFM_ex #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model


par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d15N_LFM_ex$gam)
par(mfrow = c(1, 1)) 





### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d15NYear_LFM_ex <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

d15NYear_LFM_ex <- cbind(d15NYear_LFM_ex,
                      data.frame(predict(mod_d15N_LFM_ex$gam, d15NYear_LFM_ex,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_LFM_ex <- transform(d15NYear_LFM_ex, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_LFM_ex$lake_ID <- 'LFM'

## Plot fitted trends
ggplot(d15NYear_LFM_ex, aes(x = year_CE_plot, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE_plot),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_LFM_ex))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_LFM_ex,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!

ggplot(LFM_short_extrap %>%
         filter(year_plot_extrap > 1860)) +
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_d15N.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

## d13C
Use LFM_short_extrap to be able to plot all the data vs. time, but model only the interpolated dates. 
```{r}
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_d13C_LFM <- gamm(d13C ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                     method = "REML")

summary(mod_d13C_LFM$lme) # using REML - good.

resid_values_d13C_LFM <- residuals(mod_d13C_LFM$lme, type = "normalized")
acf(resid_values_d13C_LFM) # no lag, looks good without...

## summary object for use in document
d13CSumm_LFM <- summary(mod_d13C_LFM$gam)
d13CSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d13C_LFM$gam)
par(mfrow = c(1, 1)) 


### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d13CYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

d13CYear_LFM <- cbind(d13CYear_LFM,
                      data.frame(predict(mod_d13C_LFM$gam, d13CYear_LFM,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d13CYear_LFM <- transform(d13CYear_LFM, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d13CYear_LFM$lake_ID <- 'LFM'

## Plot fitted trends
ggplot(d13CYear_LFM, aes(x = year_CE_plot, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE_plot),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = d13C), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d13C_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d13CYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, d13C)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
 #  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{13}, "C (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_d13C.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```



## percent C
```{r}

  hist(LFM_short_extrap$percent.C)
  hist(log(LFM_short_extrap$percent.C))
  
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perC_LFM <- gamm(percent.C ~ s(year_CE_plot, k = 10), 
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perC_LFM$lme) # using ML because of the Gamma family designation

resid_values_perC_LFM <- residuals(mod_perC_LFM$lme, type = "normalized")
acf(resid_values_perC_LFM) 

## summary object for use in document
perCSumm_LFM <- summary(mod_perC_LFM$gam)
perCSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perC_LFM$gam)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.C): 
fam<-family(mod_perC_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
perCYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
perCYear_LFM <- cbind(perCYear_LFM,
                      data.frame(predict(mod_perC_LFM$gam, perCYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perCYear_LFM <- transform(perCYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perCYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(perCYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.C), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perC_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perCYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Carbon (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_perC.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


## percent N
```{r}

  hist(LFM_short_extrap$percent.N)
  hist(log(LFM_short_extrap$percent.N))

# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perN_LFM <- gamm(percent.N ~ s(year_CE_plot, k = 10), 
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perN_LFM$lme) # using ML because of the Gamma family designation

resid_values_perN_LFM <- residuals(mod_perN_LFM$lme, type = "normalized")
acf(resid_values_perN_LFM) 
# negative response at lag 1

## summary object for use in document
perNSumm_LFM <- summary(mod_perN_LFM$gam)
perNSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perN_LFM$gam)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.N): 
fam<-family(mod_perN_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
perNYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perNYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
perNYear_LFM <- cbind(perNYear_LFM,
                      data.frame(predict(mod_perN_LFM$gam, perNYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perNYear_LFM <- transform(perNYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perNYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(perNYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = percent.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perN_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perNYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Nitrogen (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_perN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

## C:N -> wierd data distribution!

**Note** the wierd skew on this when compiling presentation. 

```{r}
# check later how weights, corCAR1 compare. 
    
  hist(LFM_short_extrap$C.N)
  hist(log(LFM_short_extrap$C.N))
  # data is left skewed, log transform makes it worse
    
mod_CN_LFM <- gamm(C.N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = LFM_short_extrap,
                   #  correlation = corCAR1(form = ~ year_CE_plot),
                     method = "REML")

AIC(mod_CN_LFM$lme) 
summary(mod_CN_LFM$lme)

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_CN_LFM$gam)
par(mfrow = c(1, 1)) 

# p value too low if you change anything (add car 1 etc.)

    resid_values_CN_LFM <- residuals(mod_CN_LFM$lme, type = "normalized")
    acf(resid_values_CN_LFM) 
    # residuals significant, def structured, corCAR1 helps a little bit but sample size is too small to use it.
    
## summary object for use in document
CNSumm_LFM <- summary(mod_CN_LFM$gam)
CNSumm_LFM #Gives you the P values, degrees of freedom...




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
CNYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the response scale
CNYear_LFM <- cbind(CNYear_LFM,
                      data.frame(predict(mod_CN_LFM$gam, CNYear_LFM,
                                         type="response", se.fit = TRUE)))

# calculate 95% CIs, on the response scale 

CNYear_LFM <- transform(CNYear_LFM,
  upper = fit + 2 * se.fit,
  lower = fit - 2 * se.fit)

CNYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"
     
## Plot fitted trends
ggplot(CNYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = C.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

fd_inc = confint(fderiv(mod_CN_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(CNYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, C.N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("C:N ratio") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_CN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

##Pigments
###Pheo a
```{r}
# compare data distributions
  hist(LFM_short_extrap$pheo_a_nmol_gTC)
  hist(log(LFM_short_extrap$pheo_a_nmol_gTC))
    
mod_pheoa_LFM <- gamm(pheo_a_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_pheoa_LFM$lme) # using ML because of the Gamma family designation

resid_values_pheoa_LFM <- residuals(mod_pheoa_LFM$lme, type = "normalized")
acf(resid_values_pheoa_LFM) # looks good!

## summary object for use in document
pheoaSumm_LFM <- summary(mod_pheoa_LFM$gam)
pheoaSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_pheoa_LFM$gam)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_pheoa_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
pheoaYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
pheoaYear_LFM <- cbind(pheoaYear_LFM,
                      data.frame(predict(mod_pheoa_LFM$gam, pheoaYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
pheoaYear_LFM <- transform(pheoaYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

pheoaYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(pheoaYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = pheo_a_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_pheoa_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(pheoaYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, pheo_a_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheophytin a ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_pheo_a.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Greens
```{r}

# compare data distributions
  hist(LFM_short_extrap$greens)
  hist(log(LFM_short_extrap$greens))

# check later how weights, corCAR1 compare. 
    
mod_greens_LFM <- gamm(greens ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_greens_LFM$lme) # using ML because of the Gamma family designation

resid_values_greens_LFM <- residuals(mod_greens_LFM$lme, type = "normalized")
acf(resid_values_greens_LFM) # looks good!

## summary object for use in document
greensSumm_LFM <- summary(mod_greens_LFM$gam)
greensSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_greens_LFM$gam)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_greens_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
greensYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
greensYear_LFM <- cbind(greensYear_LFM,
                      data.frame(predict(mod_greens_LFM$gam, greensYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
greensYear_LFM <- transform(greensYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

greensYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(greensYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = greens), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_greens_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(greensYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, greens)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheo b & lutein ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_greens.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Diatoxanthin
```{r}

# compare data distributions
  hist(LFM_short_extrap$diato_nmol_gTC)
  hist(log(LFM_short_extrap$diato_nmol_gTC)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_diato_LFM <- gamm(diato_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_diato_LFM$lme) # using ML because of the Gamma family designation

resid_values_diato_LFM <- residuals(mod_diato_LFM$lme, type = "normalized")
acf(resid_values_diato_LFM) # looks good

## summary object for use in document
diatoSumm_LFM <- summary(mod_diato_LFM$gam)
diatoSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_diato_LFM$gam)
par(mfrow = c(1, 1)) 

      # not great... k=index less than 1, though p-value is fine

### now transform response variable:
fam<-family(mod_diato_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
diatoYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
diatoYear_LFM <- cbind(diatoYear_LFM,
                      data.frame(predict(mod_diato_LFM$gam, diatoYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
diatoYear_LFM <- transform(diatoYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

diatoYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(diatoYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = diato_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_diato_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(diatoYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, diato_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("diatoxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_diato.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Alloxanthin
```{r}

# compare data distributions
  hist(LFM_short_extrap$allo_nmol_gTC)
  hist(log(LFM_short_extrap$allo_nmol_gTC)) # log transformation not that helpful but use it out of principle? 

    # check later how weights, corCAR1 compare. 
    
mod_allo_LFM <- gamm(allo_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_allo_LFM$lme) # using ML because of the Gamma family designation

resid_values_allo_LFM <- residuals(mod_allo_LFM$lme, type = "normalized")
acf(resid_values_allo_LFM) # looks good!

## summary object for use in document
alloSumm_LFM <- summary(mod_allo_LFM$gam)
alloSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_allo_LFM$gam)
par(mfrow = c(1, 1)) 

      # not great...? k=index = 1, though p-value is fine

### now transform response variable:
fam<-family(mod_allo_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
alloYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
alloYear_LFM <- cbind(alloYear_LFM,
                      data.frame(predict(mod_allo_LFM$gam, alloYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
alloYear_LFM <- transform(alloYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

alloYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(alloYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = allo_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_allo_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(alloYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("alloxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_allo.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Cyanos
```{r}

# compare data distributions
  hist(LFM_short_extrap$cyanos)
  hist(log(LFM_short_extrap$cyanos)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_cyanos_LFM <- gamm(cyanos ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = LFM_short_extrap,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_cyanos_LFM$lme) # using ML because of the Gamma family designation

resid_values_cyanos_LFM <- residuals(mod_cyanos_LFM$lme, type = "normalized")
acf(resid_values_cyanos_LFM) # looks good

## summary object for use in document
cyanosSumm_LFM <- summary(mod_cyanos_LFM$gam)
cyanosSumm_LFM #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_cyanos_LFM$gam)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_cyanos_LFM)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
cyanosYear_LFM <- with(LFM_short_extrap, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_LFM on the link scale
# if you do type = "response" se might still be on the link scale
cyanosYear_LFM <- cbind(cyanosYear_LFM,
                      data.frame(predict(mod_cyanos_LFM$gam, cyanosYear_LFM,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
cyanosYear_LFM <- transform(cyanosYear_LFM, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

cyanosYear_LFM$lake_ID <- 'LFM' # add a column called lake_ID filled with values "LFM"

## Plot fitted trends
ggplot(cyanosYear_LFM, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = LFM_short_extrap, mapping = aes(x = year_plot_extrap, y = cyanos), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_cyanos_LFM))
fd_inc

#Add years for plotting
years <- with(LFM_short_extrap,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(cyanosYear_LFM,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(LFM_short_extrap) +
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Lower Fourmile Lake")

ggsave("figures/LFM_cyanos.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


# TRK

## d15N
Use TRK_short. Columns are the same (year_CE_plot for interp and extrap for extrapolated)
```{r}
names(TRK_short)

### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(TRK_short$year_CE_plot)) # 10 observations... not so many
    sum(!is.na(TRK_short$year_plot_extrap)) # 41 observations. 

# try with and without corCAR1, then examine the residuals. 
mod_d15N_TRK <- gamm(d15N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_d15N_TRK$lme)

resid_values_d15N_TRK <- residuals(mod_d15N_TRK$lme, type = "normalized")
acf(resid_values_d15N_TRK) # looks good!

## summary object for use in document
d15NSumm_TRK <- summary(mod_d15N_TRK$gam)
d15NSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d15N_TRK$gam)
par(mfrow = c(1, 1)) 




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Predict (get 200 points at which to evaluate)
d15NYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

d15NYear_TRK <- cbind(d15NYear_TRK,
                      data.frame(predict(mod_d15N_TRK$gam, d15NYear_TRK,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_TRK <- transform(d15NYear_TRK, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_TRK$lake_ID <- 'TRK'

## Plot fitted trends
ggplot(d15NYear_TRK, aes(x = year_CE_plot, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE_plot),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_d15N.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

## d15N - alt
Model the full timeseries from year_plot_extrap instead of year_CE_plot - IAO
```{r}
names(TRK_short)

### K (sets the maximum # of bases for our spline): 
# Our dataset is still small: rule of thumb is to not let k approach n
    # how much data are we working with? 
    sum(!is.na(TRK_short$year_CE_plot)) # 10 observations... not so many
    sum(!is.na(TRK_short$year_plot_extrap)) # 41 observations. 

# try with and without corCAR1, then examine the residuals. 
mod_d15N_TRK <- gamm(d15N ~ s(year_plot_extrap, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_d15N_TRK$lme)

resid_values_d15N_TRK <- residuals(mod_d15N_TRK$lme, type = "normalized")
acf(resid_values_d15N_TRK) # looks good!

## summary object for use in document
d15NSumm_TRK <- summary(mod_d15N_TRK$gam)
d15NSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model

par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d15N_TRK$gam)
par(mfrow = c(1, 1)) 




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Predict (get 200 points at which to evaluate)
d15NYear_TRK <- with(TRK_short, 
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

d15NYear_TRK <- cbind(d15NYear_TRK,
                      data.frame(predict(mod_d15N_TRK$gam, d15NYear_TRK,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d15NYear_TRK <- transform(d15NYear_TRK, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d15NYear_TRK$lake_ID <- 'TRK'

## Plot fitted trends
ggplot(d15NYear_TRK, aes(x = year_plot_extrap, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_plot_extrap),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = d15N), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d15N_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_plot_extrap = seq(min(year_plot_extrap, na.rm=TRUE), max(year_plot_extrap, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_plot_extrap,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d15NYear_TRK,
                  fd_inc_timing %>% 
                    select(year_plot_extrap, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_plot_extrap") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
#Highlight area with most reliable dates
highlight_data <- tibble(xmin = 1982, xmax = 2025, ymin = -Inf, ymax = Inf)

ggplot(TRK_short) +
      #Add a box to show the reader the time period for interpretation
  geom_rect(
    mapping = aes(ymin = ymin, ymax = ymax, xmin = xmin, xmax = xmax), 
    data = highlight_data, 
    alpha = 0.1,
    fill = "blue",
    inherit.aes = FALSE
  )+
  geom_point(aes(year_plot_extrap, d15N)) +
  geom_ribbon(data = pred,
              aes(x = year_plot_extrap, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_plot_extrap, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_plot_extrap, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{15}, "N (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_d15N_alt.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


## d13C
Use TRK_short to be able to plot all the data vs. time, but model only the interpolated dates. 
```{r}

# check later how weights, corCAR1 compare. 
    
mod_d13C_TRK <- gamm(d13C ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                     method = "REML")

summary(mod_d13C_TRK$lme) # using REML - good.

resid_values_d13C_TRK <- residuals(mod_d13C_TRK$lme, type = "normalized")
acf(resid_values_d13C_TRK) # has neg lag

## summary object for use in document
d13CSumm_TRK <- summary(mod_d13C_TRK$gam)
d13CSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_d13C_TRK$gam)
par(mfrow = c(1, 1)) 


### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Second, if you're only concerned about the response, include "response" in type of predict()???
d13CYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

d13CYear_TRK <- cbind(d13CYear_TRK,
                      data.frame(predict(mod_d13C_TRK$gam, d13CYear_TRK,
                                         type="response", se.fit = TRUE)))

### this calculates on the link scale 
d13CYear_TRK <- transform(d13CYear_TRK, upper = fit + (2 * se.fit), lower = fit - (2 * se.fit))
d13CYear_TRK$lake_ID <- 'TRK'

## Plot fitted trends
ggplot(d13CYear_TRK, aes(x = year_CE_plot, y = fit)) +
  geom_ribbon(aes(ymin = (lower),
                  ymax = (upper), x = year_CE_plot),
              alpha = 0.2, inherit.aes = FALSE, fill = "black") +
  geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = d13C), inherit.aes = FALSE) +
  geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############
fd_inc = confint(fderiv(mod_d13C_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(d13CYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  #lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, d13C)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression(paste(delta^{13}, "C (", "\u2030", ")"))) +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_d13C.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```



## percent C
```{r}

# breaks = ?
  hist(TRK_short$percent.C)
  hist(log(TRK_short$percent.C))
  
# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perC_TRK <- gamm(percent.C ~ s(year_CE_plot, k = 10), 
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perC_TRK$lme) # using ML because of the Gamma family designation

resid_values_perC_TRK <- residuals(mod_perC_TRK$lme, type = "normalized")
acf(resid_values_perC_TRK) # acf looks good

## summary object for use in document
perCSumm_TRK <- summary(mod_perC_TRK$gam)
perCSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perC_TRK$gam)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.C): 
fam<-family(mod_perC_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
perCYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
perCYear_TRK <- cbind(perCYear_TRK,
                      data.frame(predict(mod_perC_TRK$gam, perCYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perCYear_TRK <- transform(perCYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perCYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(perCYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = percent.C), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perC_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perCYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, percent.C)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Carbon (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_perC.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```


## percent N
```{r}

  hist(TRK_short$percent.N)
  hist(log(TRK_short$percent.N))


# check later how weights, corCAR1 compare. 
    
# drop the "ex" for simplicity now that we know the dataset shouldn't affect the outcomes. 
mod_perN_TRK <- gamm(percent.N ~ s(year_CE_plot, k = 10), 
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_perN_TRK$lme) # using ML because of the Gamma family designation

resid_values_perN_TRK <- residuals(mod_perN_TRK$lme, type = "normalized")
acf(resid_values_perN_TRK) 
# negative response at lag 1

## summary object for use in document
perNSumm_TRK <- summary(mod_perN_TRK$gam)
perNSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_perN_TRK$gam)
par(mfrow = c(1, 1)) 

### now transform response variable (in this case percent.N): 
fam<-family(mod_perN_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
perNYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perNYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
perNYear_TRK <- cbind(perNYear_TRK,
                      data.frame(predict(mod_perN_TRK$gam, perNYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
perNYear_TRK <- transform(perNYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

perNYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(perNYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = percent.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_perN_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(perNYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, percent.N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("Total Nitrogen (%)") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_perN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

## C:N -> wierd data distribution!

**Note** the wierd skew on this when compiling presentation. 

```{r}
# this column name is annoying so change it to match LFM
  # names(TRK_short)
  # TRK_short <- rename(TRK_short, C.N = `C:N`)

# check later how weights, corCAR1 compare. 
    
  hist(TRK_short$C.N)
  hist(log(TRK_short$C.N))
  # data is left skewed, log transform makes it worse? in this case it looks a little better?
    
mod_CN_TRK <- gamm(C.N ~ s(year_CE_plot, k = 10), 
                     family = gaussian(link = "identity"), 
                     data = TRK_short,
                   #  correlation = corCAR1(form = ~ year_CE_plot),
                     method = "REML")

AIC(mod_CN_TRK$lme) 
summary(mod_CN_TRK$lme)

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_CN_TRK$gam)
par(mfrow = c(1, 1)) 

# p value too low if you change anything (add car 1 etc.)

    resid_values_CN_TRK <- residuals(mod_CN_TRK$lme, type = "normalized")
    acf(resid_values_CN_TRK) 
    # residuals significant, def structured, corCAR1 helps a little but sample size is too small to use it.
    
## summary object for use in document
CNSumm_TRK <- summary(mod_CN_TRK$gam)
CNSumm_TRK #Gives you the P values, degrees of freedom...




### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
CNYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the response scale
CNYear_TRK <- cbind(CNYear_TRK,
                      data.frame(predict(mod_CN_TRK$gam, CNYear_TRK,
                                         type="response", se.fit = TRUE)))

# calculate 95% CIs, on the response scale 

CNYear_TRK <- transform(CNYear_TRK,
  upper = fit + 2 * se.fit,
  lower = fit - 2 * se.fit)

CNYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"
     
## Plot fitted trends
ggplot(CNYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = C.N), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.

#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_CN_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(CNYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, C.N)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab("C.N ratio") +
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_CN.png",
       dpi=600,
       height=5,
       width=8,
       units="in")

```

##Pigments
###Pheo a
```{r}
# compare data distributions
  hist(TRK_short$pheo_a_nmol_gTC)
  hist(log(TRK_short$pheo_a_nmol_gTC)) # better!

    # check later how weights, corCAR1 compare. 
    
mod_pheoa_TRK <- gamm(pheo_a_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_pheoa_TRK$lme) # using ML because of the Gamma family designation

resid_values_pheoa_TRK <- residuals(mod_pheoa_TRK$lme, type = "normalized")
acf(resid_values_pheoa_TRK) # looks good!

## summary object for use in document
pheoaSumm_TRK <- summary(mod_pheoa_TRK$gam)
pheoaSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_pheoa_TRK$gam)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_pheoa_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
pheoaYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
pheoaYear_TRK <- cbind(pheoaYear_TRK,
                      data.frame(predict(mod_pheoa_TRK$gam, pheoaYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
pheoaYear_TRK <- transform(pheoaYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

pheoaYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(pheoaYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = pheo_a_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_pheoa_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(pheoaYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, pheo_a_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheophytin a ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_pheo_a.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```
###Greens
```{r}
# compare data distributions
  hist(TRK_short$greens)
  hist(log(TRK_short$greens)) # log is better

    # check later how weights, corCAR1 compare. 
    
mod_greens_TRK <- gamm(greens ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")


summary(mod_greens_TRK$lme) # using ML because of the Gamma family designation

resid_values_greens_TRK <- residuals(mod_greens_TRK$lme, type = "normalized")
acf(resid_values_greens_TRK) # looks good!

## summary object for use in document
greensSumm_TRK <- summary(mod_greens_TRK$gam)
greensSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_greens_TRK$gam)
par(mfrow = c(1, 1)) 


### now transform response variable:
fam<-family(mod_greens_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
greensYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
greensYear_TRK <- cbind(greensYear_TRK,
                      data.frame(predict(mod_greens_TRK$gam, greensYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
greensYear_TRK <- transform(greensYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

greensYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(greensYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = greens), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_greens_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(greensYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, greens)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("pheo b & lutein ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_greens.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Diatoxanthin
```{r}

# compare data distributions
  hist(TRK_short$diato_nmol_gTC)
  hist(log(TRK_short$diato_nmol_gTC)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_diato_TRK <- gamm(diato_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_diato_TRK$lme) # using ML because of the Gamma family designation

resid_values_diato_TRK <- residuals(mod_diato_TRK$lme, type = "normalized")
acf(resid_values_diato_TRK) # same negative acf right at lag 1, not huge though

## summary object for use in document
diatoSumm_TRK <- summary(mod_diato_TRK$gam)
diatoSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_diato_TRK$gam)
par(mfrow = c(1, 1)) 

      # not great... k=index less than 1, though p-value is fine

### now transform response variable:
fam<-family(mod_diato_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
diatoYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
diatoYear_TRK <- cbind(diatoYear_TRK,
                      data.frame(predict(mod_diato_TRK$gam, diatoYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
diatoYear_TRK <- transform(diatoYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

diatoYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(diatoYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = diato_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_diato_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(diatoYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, diato_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("diatoxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_diato.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Alloxanthin
```{r}

# compare data distributions
  hist(TRK_short$allo_nmol_gTC)
  hist(log(TRK_short$allo_nmol_gTC)) # log transformation not that helpful but use it out of principle? 

    # check later how weights, corCAR1 compare. 
    
mod_allo_TRK <- gamm(allo_nmol_gTC ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_allo_TRK$lme) # using ML because of the Gamma family designation

resid_values_allo_TRK <- residuals(mod_allo_TRK$lme, type = "normalized")
acf(resid_values_allo_TRK) # looks good!

## summary object for use in document
alloSumm_TRK <- summary(mod_allo_TRK$gam)
alloSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_allo_TRK$gam)
par(mfrow = c(1, 1)) 

      # not great...? k=index = 1, though p-value is fine

### now transform response variable:
fam<-family(mod_allo_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
alloYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
alloYear_TRK <- cbind(alloYear_TRK,
                      data.frame(predict(mod_allo_TRK$gam, alloYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
alloYear_TRK <- transform(alloYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

alloYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(alloYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = allo_nmol_gTC), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_allo_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(alloYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, allo_nmol_gTC)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("alloxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_allo.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

###Cyanos
```{r}

# compare data distributions
  hist(TRK_short$cyanos)
  hist(log(TRK_short$cyanos)) # log transformation is rly helpful

    # check later how weights, corCAR1 compare. 
    
mod_cyanos_TRK <- gamm(cyanos ~ s(year_CE_plot, k = 10),
                     family=Gamma(link="log"),  
                     data = TRK_short,
                     # REML only works for gaussian data
                     method = "ML")

summary(mod_cyanos_TRK$lme) # using ML because of the Gamma family designation

resid_values_cyanos_TRK <- residuals(mod_cyanos_TRK$lme, type = "normalized")
acf(resid_values_cyanos_TRK) # looks good

## summary object for use in document
cyanosSumm_TRK <- summary(mod_cyanos_TRK$gam)
cyanosSumm_TRK #Gives you the P values, degrees of freedom...

### Check diagnostics. You might need to adjust model
par(mfrow = c(2, 2))   # Set up a 2x2 grid
gam.check(mod_cyanos_TRK$gam)
par(mfrow = c(1, 1)) 

### now transform response variable:
fam<-family(mod_cyanos_TRK)
fam # this is a list of 13
ilink <- fam$linkinv
ilink 

### NOW PLOT! ###
N <- 300    # number of points at which to evaluate the splines

# Make a 200 row list of possible year_CE_plot values from min to max.
cyanosYear_TRK <- with(TRK_short, 
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), 
                                                   max(year_CE_plot, na.rm=TRUE), 
                                                   length.out = 200)))

# predict fit (response variable) and se for perCYear_TRK on the link scale
# if you do type = "response" se might still be on the link scale
cyanosYear_TRK <- cbind(cyanosYear_TRK,
                      data.frame(predict(mod_cyanos_TRK$gam, cyanosYear_TRK,
                                         type="link", se.fit = TRUE)))

# calculate 95% CIs, then transform back to the response scale 
cyanosYear_TRK <- transform(cyanosYear_TRK, fit   = ilink(fit),
  upper = ilink(fit + 2 * se.fit),
  lower = ilink(fit - 2 * se.fit))

cyanosYear_TRK$lake_ID <- 'TRK' # add a column called lake_ID filled with values "TRK"

## Plot fitted trends
ggplot(cyanosYear_TRK, aes(x = year_CE_plot, y = fit)) + # year_CE_plot is the interp time var
geom_ribbon(aes(ymin = (lower),
                ymax = (upper), x = year_CE_plot),
            alpha = 0.2, inherit.aes = FALSE, fill = "black") +
      geom_point(data = TRK_short, mapping = aes(x = year_plot_extrap, y = cyanos), inherit.aes = FALSE) +
      geom_line() 

# year_plot_extrap = year_CE_plot where dates are interpolated. Can use either for plotting points.



#First derivatives using gratia package instead of the 
#functions "helper_functions.R" (that Cale sent)
############
############

# all these are calculate on the link scale log(mu) because the model specifies the gamma family
fd_inc = confint(fderiv(mod_cyanos_TRK))
fd_inc

#Add years for plotting
years <- with(TRK_short,
                     data.frame(year_CE_plot = seq(min(year_CE_plot, na.rm=TRUE), max(year_CE_plot, na.rm=TRUE), length.out = 200)))

fd_inc <- cbind(fd_inc,years)

#Plot the first derivatives
fd_inc %>%
  select(-term) %>%
  pivot_longer(lower:upper) %>%
  ggplot(aes(x=year_CE_plot,y=value,linetype=name))+
  geom_line()+
    scale_linetype_manual(values = c(
    "lower" = "dashed", #lower 95% confidence interval
    "upper" = "dashed", #upper 95% confidence interval
    "est"   = "solid"
  ))+
  theme(legend.position="none")+
  geom_hline(yintercept=0, color="red")
# Anywhere the confidence intervals DONT overlap zero is a statistically
# significant acceleration or deceleration in the trend


# When do they occur? You can check with an if/else type statement
fd_inc_timing <- fd_inc %>%
  mutate(change_type = case_when(lower < 0 & upper < 0 ~ "sig. dec.",
                                 lower > 0 & upper > 0 ~ "sig. inc.",
                                 TRUE ~ NA))
# View(fd_inc_timing)
#What you can see if a brief period of decline ~1900-1934, and again from 
#1960-present. This model, relative to Cale's seems more sensitive to that
#slight increase pre-1900. I think Cale's weighting is probably better

# For graphing, we want to join the predicted/fitted data with the 
# information with significant periods of change. Let's call it 'pred'

pred <- left_join(cyanosYear_TRK,
                  fd_inc_timing %>% 
                    select(year_CE_plot, change_type), #select only 2 columns since
                  # lower and upper have two different meanings in these 2 dataframes
                  by="year_CE_plot") 
  # mutate(fit = ifelse(change_type == "sig. dec.", fit, NA))

# Add a segment ID for plotting, so there there are multiple
# periods of change, ggplot doesn't connect the lines together
pred2 <- pred %>%
  mutate(seg_id = with(rle(ifelse(is.na(change_type), "none", change_type)),
                       rep(seq_along(values), lengths)))

# Keep only rows that are sig. inc or sig. dec
pred2 <- pred2 %>% filter(!is.na(change_type))

# Now make a pretty graph that shows the raw data, fitted trend,
# trend as well as periods of statistically significant increase/decrease!
ggplot(TRK_short) +
  geom_point(aes(year_plot_extrap, cyanos)) +
  geom_ribbon(data = pred,
              aes(x = year_CE_plot, ymin = lower, ymax = upper),
              alpha = 0.2) +
  geom_line(data = pred,
            aes(x = year_CE_plot, y = fit),
            linewidth = 1,
            color = "black") +
  geom_line(data = pred2,
            aes(x = year_CE_plot, y = fit,
                color = change_type,
                group = seg_id),
            linewidth = 1) +
  scale_color_manual(values = c("sig. inc." = "#CC9933",
                                "sig. dec." = "#2f6cad"),
                     name ="Statistic") +
  # scale_x_continuous(breaks=seq(1880,2025,by=25))+
  ylab(expression("echinenone & canthaxanthin ("*nmol~g^-1~"total carbon"*")")) + 
  xlab(expression(paste("Year (", italic("CE"), ")"))) +
  ggtitle("Turkey Creek Lake")

ggsave("figures/TRK_cyanos.png",
       dpi=600,
       height=5,
       width=8,
       units="in")
```

# Example Code removed